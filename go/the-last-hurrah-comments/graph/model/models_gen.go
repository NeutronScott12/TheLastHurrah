// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type ApplicationModel struct {
	ID                    string          `json:"id"`
	ModeratorsIds         []string        `json:"moderators_ids"`
	AuthenticatedUsersIds []string        `json:"authenticated_users_ids"`
	Comments              []*CommentModel `json:"comments"`
}

type ApproveCommentsInput struct {
	CommentIds []string `json:"comment_ids"`
}

type ChangeCommentSettingsInput struct {
	CommentID         string `json:"comment_id"`
	ReplyNotification bool   `json:"reply_notification"`
}

type CommentAndVoteCountEntity struct {
	CommentCount int `json:"comment_count"`
	VoteCount    int `json:"vote_count"`
}

type CommentModel struct {
	ID                 string          `json:"ID"`
	CreatedAt          string          `json:"created_at"`
	UpdatedAt          string          `json:"updated_at"`
	Author             *UserModel      `json:"author"`
	ThreadID           string          `json:"thread_id"`
	ParentID           *string         `json:"parent_id"`
	PlainTextBody      string          `json:"PlainTextBody"`
	JSONBody           []string        `json:"json_body"`
	UpVote             []*RatingModel  `json:"up_vote"`
	DownVote           []*RatingModel  `json:"down_vote"`
	ThreateningContent bool            `json:"threatening_content"`
	PrivateInformation bool            `json:"private_information"`
	Deleted            bool            `json:"deleted"`
	Flagged            bool            `json:"flagged"`
	Pending            bool            `json:"pending"`
	Approved           bool            `json:"approved"`
	RepliedToID        *string         `json:"replied_to_id"`
	UserID             string          `json:"user_id"`
	ApplicationID      string          `json:"application_id"`
	Reports            []*ReportModel  `json:"reports"`
	Replies            []*CommentModel `json:"replies"`
	Count              *CountModel     `json:"_count"`
}

type CommentsByUserIDInput struct {
	UserID *string `json:"user_id"`
}

type CountModel struct {
	UpVote   int `json:"up_vote"`
	DownVote int `json:"down_vote"`
	Replies  int `json:"replies"`
}

type CreateCommentInput struct {
	PlainTextBody string `json:"plain_text_body"`
	JSONBody      string `json:"json_body"`
	ApplicationID string `json:"application_id"`
	ThreadID      string `json:"thread_id"`
}

type CreateReplyCommentInput struct {
	PlainTextBody string `json:"plain_text_body"`
	JSONBody      string `json:"json_body"`
	ApplicationID string `json:"application_id"`
	ThreadID      string `json:"thread_id"`
	ParentID      string `json:"parent_id"`
	RepliedToID   string `json:"replied_to_id"`
}

type CreateReportInput struct {
	CommentID string       `json:"comment_id"`
	Report    ReportReason `json:"report"`
}

type DeleteManyCommentsInput struct {
	CommentIds      []string `json:"comment_ids"`
	PermanentDelete bool     `json:"permanent_delete"`
}

type FetchAllComments struct {
	CommentsCount int             `json:"CommentsCount"`
	Comments      []*CommentModel `json:"Comments"`
}

type FetchCommentAndVoteCountInput struct {
	UserID string `json:"user_id"`
}

type FetchCommentByApplicationName struct {
	CommentsCount float64         `json:"comments_count"`
	Comments      []*CommentModel `json:"comments"`
}

type FetchCommentByThreadIDInput struct {
	Limit                int    `json:"limit"`
	Skip                 int    `json:"skip"`
	Sort                 Sort   `json:"sort"`
	ThreadID             string `json:"thread_id"`
	ApplicationShortName string `json:"application_short_name"`
}

type FetchCommentByThreadIDResponse struct {
	CommentsCount float64         `json:"comments_count"`
	Comments      []*CommentModel `json:"comments"`
}

type FetchCommentsByApplicationID struct {
	CommentsCount float64         `json:"comments_count"`
	Comments      []*CommentModel `json:"comments"`
}

type FetchCommentsByApplicationIDInput struct {
	Limit                int    `json:"limit"`
	Skip                 int    `json:"skip"`
	Sort                 *Sort  `json:"sort"`
	ApplicationShortName string `json:"application_short_name"`
	ApplicationID        string `json:"application_id"`
}

type FetchCommentsByApplicationShortNameInput struct {
	Limit                int    `json:"limit"`
	Skip                 int    `json:"skip"`
	Sort                 *Sort  `json:"sort"`
	ApplicationShortName string `json:"application_short_name"`
	Where                Where  `json:"where"`
}

type FetchThreadCommentsBySort struct {
	Limit int   `json:"limit"`
	Skip  int   `json:"skip"`
	Sort  *Sort `json:"sort"`
}

type ProfileEntity struct {
	ID              string          `json:"id"`
	ProfileComments []*CommentModel `json:"profile_comments"`
}

type RatingModel struct {
	ID       string `json:"id"`
	AuthorID string `json:"author_id"`
}

type ReportModel struct {
	ID        string       `json:"id"`
	UserID    string       `json:"user_id"`
	Reason    ReportReason `json:"reason"`
	CreatedAt string       `json:"created_at"`
	UpdatedAt string       `json:"updated_at"`
}

type StandardResponseModel struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

type ThreadModel struct {
	// UUID for Thread
	ID                 string                          `json:"id"`
	PinnedCommentID    *string                         `json:"pinned_comment_id"`
	SubscribedUsersIds []string                        `json:"subscribed_users_ids"`
	PinnedComment      *CommentModel                   `json:"pinned_comment"`
	ThreadComments     *FetchCommentByThreadIDResponse `json:"thread_comments"`
}

type UpdateCommentInput struct {
	PlainTextBody string `json:"plain_text_body"`
	JSONBody      string `json:"json_body"`
	CommentID     string `json:"comment_id"`
}

type UserModel struct {
	ID string `json:"id"`
}

type ReportReason string

const (
	ReportReasonDisagree             ReportReason = "DISAGREE"
	ReportReasonSpam                 ReportReason = "SPAM"
	ReportReasonInappropriateProfile ReportReason = "INAPPROPRIATE_PROFILE"
	ReportReasonThreateningContent   ReportReason = "THREATENING_CONTENT"
	ReportReasonPrivateInformation   ReportReason = "PRIVATE_INFORMATION"
)

var AllReportReason = []ReportReason{
	ReportReasonDisagree,
	ReportReasonSpam,
	ReportReasonInappropriateProfile,
	ReportReasonThreateningContent,
	ReportReasonPrivateInformation,
}

func (e ReportReason) IsValid() bool {
	switch e {
	case ReportReasonDisagree, ReportReasonSpam, ReportReasonInappropriateProfile, ReportReasonThreateningContent, ReportReasonPrivateInformation:
		return true
	}
	return false
}

func (e ReportReason) String() string {
	return string(e)
}

func (e *ReportReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReportReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid REPORT_REASON", str)
	}
	return nil
}

func (e ReportReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Sort string

const (
	SortAsc      Sort = "ASC"
	SortDesc     Sort = "DESC"
	SortTopVotes Sort = "TOP_VOTES"
)

var AllSort = []Sort{
	SortAsc,
	SortDesc,
	SortTopVotes,
}

func (e Sort) IsValid() bool {
	switch e {
	case SortAsc, SortDesc, SortTopVotes:
		return true
	}
	return false
}

func (e Sort) String() string {
	return string(e)
}

func (e *Sort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Sort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid sort", str)
	}
	return nil
}

func (e Sort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Where string

const (
	WherePending Where = "PENDING"
	WhereAppoved Where = "APPOVED"
	WhereSpam    Where = "SPAM"
	WhereDeleted Where = "DELETED"
	WhereAll     Where = "ALL"
)

var AllWhere = []Where{
	WherePending,
	WhereAppoved,
	WhereSpam,
	WhereDeleted,
	WhereAll,
}

func (e Where) IsValid() bool {
	switch e {
	case WherePending, WhereAppoved, WhereSpam, WhereDeleted, WhereAll:
		return true
	}
	return false
}

func (e Where) String() string {
	return string(e)
}

func (e *Where) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Where(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid where", str)
	}
	return nil
}

func (e Where) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
